+++
title = "RAGで回答の質が高くなるのか試してみた"
date = "2025-02-19"
categories = [

]
tags = [
  "生成AI",
  "Ruby"
]
+++

ChatGPTのProjects機能（RAG: Retrieval-Augmented Generation）を使って、回答の質が向上するのかを実験してみました。具体的には、Ruby 3.4.1の組み込みライブラリのドキュメントを使って、同じLLMモデルに同じ質問をした際の回答の質を比較しました。

## RAGとは？

RAG（Retrieval-Augmented Generation）は、大規模言語モデル（LLM）の回答生成プロセスを拡張する手法です。事前に用意した文書やデータベースから、質問に関連する情報を検索（Retrieval）し、その情報を元に回答を生成（Generation）します。

ChatGPTのProjects機能は、このRAGを実現する機能の一つです。ユーザーが独自のドキュメントを登録しておくことで、そのドキュメントの内容を参照した、より正確で文脈に即した回答を得ることができます。

## 実験の概要

今回の実験では、以下のような条件で回答の質を比較しました：

1. Ruby 3.4.1の組み込みライブラリのドキュメントをProjectsに登録
   - 標準添付ライブラリは対象外
   - 以下のスクリプトを使用してドキュメントを生成

<details>
<summary>ドキュメント生成スクリプト</summary>

```ruby
ruby_version = RUBY_VERSION.gsub('.', '_')
output_file = "ruby_builtin_docs_#{ruby_version}.txt"

builtins = Object.constants.select do |const|
  begin
    obj = Object.const_get(const)
    obj.is_a?(Class) || obj.is_a?(Module)
  rescue StandardError
    false
  end
end.sort_by(&:to_s)

File.open(output_file, "w") do |file|
  file.puts "Ruby Version: #{RUBY_VERSION} (#{RUBY_RELEASE_DATE})"
  file.puts RUBY_DESCRIPTION
  file.puts "\n" + "=" * 80 + "\n\n"

  builtins.each do |name|
    file.puts "==== #{name} ===="
    # 出力を "col -b" でパイプ処理し、制御文字を除去
    ri_output = `ri #{name} 2>&1 | col -b`
    file.puts ri_output
    file.puts "\n" + "-" * 80 + "\n"
  end
end

puts "組み込みライブラリのドキュメントを '#{output_file}' に出力完了しました。"
```
</details>

2. 同じLLMモデル（o3-mini-high）に対して、以下のパターンで質問：
   - Projects機能使用 + ドキュメント範囲内の質問
   - Projects機能使用 + ドキュメント範囲外の質問
   - Projects機能不使用 + ドキュメント範囲内の質問
   - Projects機能不使用 + ドキュメント範囲外の質問

注意点として、Projects機能のinstructionsを追加すると、gpt-4o以外のモデルを選択できなくなるため、instructionsは使用しませんでした。

## 実験結果

### 1. ドキュメント範囲内の質問（IOクラスの特異メソッド）

まず、実際のRuby 3.4.1におけるIOクラスの特異メソッド一覧を確認します：

<details>
<summary>irbでのIO.singleton_methods実行結果</summary>

```ruby
irb(main):001> RUBY_VERSION
=> "3.4.1"
irb(main):002> IO.singleton_methods
=> [:select, :sysopen, :for_fd, :popen, :foreach, :binread, :binwrite, :pipe, :copy_stream, :console, :open, :readlines, :write, :try_convert, :read, :new, :yaml_tag]
```
</details>

#### Projects機能使用時の回答（出力時間：15秒）

<details>
<summary>Projects機能使用時の出力結果</summary>

> 以下は、Ruby 3.4におけるIOクラスの特異メソッド（＝クラスメソッド）の一覧と、それぞれの仕様の解説です。以下の各メソッドは、主にファイルやプロセスとの低レベルな入出力操作や、ストリームの生成・操作のために用いられます。
>
> ---
>
> 【1. IO.binread】
>
> ・概要:
> ファイル全体または指定バイト数をバイナリモードで読み込み、バイナリ文字列（Encoding::ASCII_8BITの文字列）を返します。
> ・主な用途:
> テキスト変換などの余計な処理を行わず、ファイルの生データをそのまま取得したい場合に使用します。
>
> ---
>
> 【2. IO.binwrite】
>
> ・概要:
> 指定したファイルに対して、バイナリモードでデータを書き込みます。
> ・特徴:
> 書き込む内容はそのままのバイト列として扱われ、エンコーディング変換が行われません。新規作成時や上書き時に便利です。
>
> ---
>
> 【3. IO.console】
>
> ・概要:
> 現在の端末（コンソール）に関連付けられたIOオブジェクトを返します。
> ・用途:
> 端末専用の機能（例えば、入力モードの変更やカーソル操作など）を利用する際に使用されます。（ただし、io/consoleライブラリが必要です）
>
> ---
>
> 【4. IO.copy_stream】
>
> ・概要:
> ソース（ファイルパスまたはIOオブジェクト）からデスティネーション（同様にファイルパスまたはIOオブジェクト）へ、データを効率的にコピーします。
> ・特徴:
> ファイル間のコピーや、IO同士の転送を1行の呼び出しで行えるため、低レベルなコピー処理を簡潔に実装できます。
>
> ---
>
> 【5. IO.for_fd】
>
> ・概要:
> 与えられた整数のファイルディスクリプタに対して、対応するIOオブジェクトを生成します。
> ・用途:
> すでにオープンされているファイル記述子（たとえば、低レベルAPIや組み込みのファイルディスクリプタ）を高水準のIO操作で扱いたい場合に利用されます。
>
> ---
>
> 【6. IO.foreach】
>
> ・概要:
> 指定したファイルを行単位でオープンし、各行をブロックに渡して反復処理を行います。
> ・特徴:
> 内部でファイルを開き、ブロック処理後は自動的にクローズされるため、大きなファイルを効率的に逐次処理できます。
>
> ---
>
> 【7. IO.new】
>
> ・概要:
> 与えられたファイルディスクリプタから新しいIOオブジェクトを生成します。
> ・用途:
> 低レベルのファイルディスクリプタを高水準のIOオブジェクトに変換する際に用いられ、for_fdと同様の役割を持ちます。
>
> ---
>
> 【8. IO.open】
>
> ・概要:
> ファイルをオープンして対応するIOオブジェクトを返します。
> ・特徴:
> ブロック付きで呼び出すと、ブロック終了時に自動でクローズされるため、リソース管理が容易になります。
>
> ---
>
> 【9. IO.pipe】
>
> ・概要:
> 読み取り側と書き込み側が接続されたパイプのIOオブジェクトのペア（2要素の配列）を生成します。
> ・用途:
> プロセス間通信（IPC）や、並列処理でのデータ受け渡しに利用されます。
>
> ---
>
> 【10. IO.popen】
>
> ・概要:
> サブプロセスを起動し、その標準入出力（あるいはエラー出力）に接続されたIOオブジェクトを返します。
> ・特徴:
> バックグラウンドでコマンドを実行し、プロセスとの通信が可能になるため、外部コマンドとの連携に適しています。
>
> ---
>
> 【11. IO.read】
>
> ・概要:
> 指定されたファイル（またはパス）から、全内容または指定バイト数だけを読み込んで文字列として返します。
> ・注意点:
> テキストモードで開かれるため、エンコーディング変換が適用されます（必要に応じてモード指定も可能）。
>
> ---
>
> 【12. IO.readlines】
>
> ・概要:
> ファイル全体を行ごとの配列として読み込み、各行を要素とする配列を返します。
> ・用途:
> ファイル全体の内容を行単位で一括して処理したい場合に利用されます。
>
> ---
>
> 【13. IO.select】
>
> ・概要:
> 与えられたIOオブジェクト群のうち、読み込み可能／書き込み可能／例外状態にあるものを待ち、準備が整ったIOオブジェクトを配列として返します。
> ・特徴:
> ノンブロッキングI/Oや複数のIO待ちを行う際に使用され、タイムアウトの指定も可能です。
>
> ---
>
> 【14. IO.sysopen】
>
> ・概要:
> 低レベルのシステムコールを利用してファイルをオープンし、ファイルディスクリプタ（整数値）を返します。
> ・用途:
> システムレベルでのファイル操作を行いたい場合に、後でIO.newなどで高水準IOオブジェクトに変換するために使用されます。
>
> ---
>
> 【15. IO.try_convert】
>
> ・概要:
> 引数のオブジェクトがIOのような振る舞い（to_ioメソッドの実装など）を持っているか試し、変換可能ならばそのIOオブジェクトを返します。
> ・特徴:
> オブジェクトがIOに変換できるかどうかを確認するためのユーティリティメソッドとして機能します。
>
> ---
>
> 【16. IO.write】
>
> ・概要:
> 指定されたファイル（またはパス）に対して、データを書き込みます。
> ・特徴:
> 一度に全データを書き込む場合に便利で、書き込み後のバイト数を返します。モードやエンコーディングを指定して呼び出すことも可能です。
>
> ---
>
> 以上が、Ruby 3.4のIOクラスに定義されている主要な特異メソッド（クラスメソッド）の一覧とその解説です。これらのメソッドは、入出力ストリームの生成・操作や、低レベルのファイルアクセス、プロセスとの連携など、多岐にわたる用途に対応するために用意されています。
</details>

- メソッドの網羅性：◎
  - 実際のRubyドキュメントに基づいて、16個のメソッドすべてを正確に列挙
  - 各メソッドの詳細な仕様を体系的に解説

- 説明の正確性：◎
  - 各メソッドの用途や特徴を具体的に説明
  - 引数の型や戻り値についても詳細に解説

- 構造化：◎
  - メソッドごとに見出しを付け、整理された形で情報を提示
  - 概要、特徴、用途などを分けて説明

#### Projects機能不使用時の回答（出力時間：41秒）

<details>
<summary>Projects機能不使用時の出力結果</summary>

> Ruby 3.4におけるIOクラスの特異メソッドは以下の9つである。
>
> IO.new(fd, mode = "r", opt = {})
> 既にオープンされたファイルディスクリプタからIOオブジェクトを生成する。
>
> fd：整数のファイルディスクリプタを指定する。
> mode：入出力モードを文字列で指定する（例："r", "w" など）。
> opt：ハッシュ形式で各種オプション（例：close_on_execなど）を渡す。
>
> IO.open(*args) { ... }
> 基本的にはIO.newと同等の動作をするが、ブロック付きで呼び出すとブロック終了後に自動的にIOオブジェクトがクローズされる。
>
> ブロック付き呼び出しによりリソース管理が容易になる。
>
> IO.sysopen(path, mode = "r", perm = 0644)
> システムコールのopen(2)をラップする。
>
> path：オープンするファイルのパスを指定する。
> mode：入出力モードを文字列で指定する。
> perm：ファイルのパーミッション（整数値、デフォルトは0644）を指定し、成功するとファイルディスクリプタ（整数値）を返す。
>
> IO.popen(cmd, mode = "r", opt = {}) { ... }
> コマンドを実行し、その入出力に接続されたIOオブジェクトを生成する。
>
> cmd：実行するコマンドを文字列または配列で指定する。
> mode：IOの入出力方向（例："r"で読み込み、"w"で書き込み）を指定する。
> ブロック付き呼び出しの場合、ブロック終了後にプロセスの終了待ちおよび自動クローズが行われる。
>
> IO.foreach(name, sep = $/, limit = nil, encoding = nil, open_args) { |line| ... }
> 指定されたファイルをオープンし、行単位でブロックを呼び出す。
>
> name：対象ファイルのパスを指定する。
> sep：行の区切り文字（デフォルトは改行文字）を指定する。
> limit：各行から読み込む最大文字数を指定できる。
> encoding：文字エンコーディングを指定する。
> ファイルは全行処理後、自動的にクローズされる。
>
> IO.pipe
> プロセス間通信などに用いられるパイプを生成し、読み込み側と書き込み側のIOオブジェクトのペア（配列）を返す。
>
> ブロック付き呼び出しの場合、生成されたIOオブジェクトがブロックに渡され、ブロック終了後に自動的にクローズされる。
>
> IO.select(read_array, write_array = nil, error_array = nil, timeout = nil)
> 複数のIOオブジェクトの状態（読み込み可能、書き込み可能、エラー発生状態）を監視するためのメソッドである。
>
> read_array：読み込み可能性を監視するIOオブジェクトの配列。
> write_array、error_array：それぞれ書き込み可能性およびエラー状態を監視する配列。
> timeout：待機時間を秒単位で指定する。
> 状態変化があれば該当するIOオブジェクトの配列の配列を返し、タイムアウト時はnilを返す。
>
> IO.copy_stream(src, dst, max_length = nil, offset = nil)
> srcからdstへデータを高速にコピーする。
>
> src：読み込み元。IOオブジェクトまたはファイルパスが指定可能。
> dst：書き込み先。IOオブジェクトまたはファイルパスが指定可能。
> max_length：コピーする最大バイト数を指定できる。
> offset：コピー開始位置を指定できる。
> 戻り値はコピーされたバイト数である。
>
> IO.try_convert(obj)
> オブジェクトobjがIOとして利用可能かを試す。
>
> objがto_ioメソッドを実装していれば、その戻り値を返し、実装していなければnilを返す。
> 主にオブジェクトの型変換を試みるために利用される。
>
> 以上がRuby 3.4におけるIOクラスの特異メソッドである。
</details>

- メソッドの網羅性：△
  - 実際の16メソッドに対して9メソッドのみを列挙
  - 重要なメソッド（binread, binwrite, console等）が欠落

- 説明の正確性：○
  - 列挙されたメソッドについては、基本的な機能を正しく説明
  - ただし、詳細な使用例や注意点などの情報は限定的

- 構造化：○
  - メソッドごとに説明を分けて記述
  - 基本的な構造は整っているが、Projects使用時と比べると情報量が少ない

### 2. ドキュメント範囲外の質問（Dateクラスの特異メソッド）

実際のDateクラスの特異メソッド一覧：

<details>
<summary>irbでのDate.singleton_methods実行結果</summary>

```ruby
irb(main):003> Date.singleton_methods
=>
[:_load,
 :valid_jd?,
 :valid_ordinal?,
 :valid_civil?,
 :valid_date?,
 :valid_commercial?,
 :julian_leap?,
 :gregorian_leap?,
 :leap?,
 :jd,
 :ordinal,
 :civil,
 :commercial,
 :_strptime,
 :strptime,
 :_parse,
 :_iso8601,
 :_rfc3339,
 :rfc3339,
 :_xmlschema,
 :_rfc2822,
 :_rfc822,
 :rfc2822,
 :rfc822,
 :today,
 :_httpdate,
 :httpdate,
 :_jisx0301,
 :jisx0301,
 :parse,
 :xmlschema,
 :iso8601,
 :yaml_tag]
```
</details>

#### Projects機能使用時の回答（出力時間：10秒）

<details>
<summary>Projects機能使用時の出力結果</summary>

> 以下は、Ruby 3.4 の標準添付ライブラリで提供される Date クラスの特異メソッド（Date.xxx）とその仕様の概要です。各メソッドは、さまざまな形式の日付表現を Date オブジェクトに変換するために用いられています。詳細な仕様は Ruby の組み込みドキュメントに記載されており、例えば や に記述されています。
>
> • new
> Date.new は、年、月、日などの数値を引数として受け取り、新しい Date オブジェクトを生成します。引数が不正（例：存在しない日付など）である場合、ArgumentError を発生させる仕様です。
>
> • parse
> Date.parse は、日付を表す文字列（例："2024-01-01"）を解析し、対応する Date オブジェクトに変換します。多様な日付フォーマットを柔軟に解釈するため、曖昧な表現も適宜処理します。
>
> • strptime
> Date.strptime は、フォーマット文字列（例："%Y-%m-%d"）を指定して、与えられた文字列を厳密に解析します。入力フォーマットが明確な場合に、意図した通りの Date オブジェクトを生成するために利用されます。
>
> • iso8601
> ISO 8601 形式（例："2024-01-01"）の文字列を解析して Date オブジェクトを返します。ISO 規格に準拠した日付データを扱う際に用いられます。
>
> • rfc2822（エイリアスとして rfc822 も存在）
> RFC 2822（または古い RFC 822）形式の文字列を解析し、Date オブジェクトに変換します。主にメールヘッダーなど、RFC に従った日付表現の処理に使用されます。
>
> • httpdate
> HTTP プロトコルで定義される日付（RFC 1123 のバリアントなど）を解析し、Date オブジェクトを生成します。HTTP ヘッダーで使用される日付形式に対応しています。
>
> • xmlschema
> XML Schema の日付形式に準拠した文字列を解析して、Date オブジェクトを返します。XML ドキュメント内の日付情報の取り扱いに適しています。
>
> • json_create
> JSON 形式でシリアライズされた Date オブジェクトを、デシリアライズ時に再構築するためのメソッドです。JSON ライブラリとの連携により、シリアライズ／デシリアライズの際に利用されます。
>
> • zone_offset
> （提供されている場合）zone_offset は、タイムゾーンを示す文字列からオフセット値を計算するためのメソッドです。Date クラス自体は日付のみを扱いますが、文字列から日付への変換時にタイムゾーン情報を補正する用途で利用されることがあります。
>
> これらの特異メソッドは、日付データの入力形式に応じて適切な Date オブジェクトを生成するためのツール群として設計されています。いずれも、入力が不正な場合や範囲外の値が指定された場合には、Ruby の一貫した例外（通常は ArgumentError など）を発生させる仕様となっています。
>
> より詳しい動作例やエッジケースについては、Ruby 3.4 の公式ドキュメント（、）を参照してください。
</details>

- メソッドの網羅性：△
  - 実際の33メソッドに対して、主要なメソッドのみを説明
  - 内部メソッド（_で始まるメソッド）は意図的に省略している可能性

- 説明の正確性：○
  - 説明された各メソッドの基本的な機能は正確
  - ただし、詳細な仕様や使用例は限定的

- 構造化：△
  - メソッドの説明は箇条書きで提示
  - 体系的な整理や分類がやや不足

#### Projects機能不使用時の回答（出力時間：34秒）

<details>
<summary>Projects機能不使用時の出力結果</summary>

> 以下、Ruby 3.4の標準添付ライブラリであるDateクラスの特異メソッド（クラスメソッド）を漏れなく列挙し、それぞれの仕様を解説する。
>
> Date.new / Date.civil
> 年、月、日（省略時は月＝1、日＝1）および暦の切替点（既定はDate::ITALY）を与えて、元号やグレゴリオ暦に基づく新しいDateオブジェクトを生成する。
> ※ Date.civilはDate.newの別名である。
>
> Date.commercial
> ISO 8601形式の週番号（年、週、週内の日＝1～7、既定は1＝月曜日）を指定して、対応するDateオブジェクトを生成する。
> 生成時に暦の切替点をオプションで指定できる。
>
> Date.ordinal
> 年と年内通算日（1～366）を指定して、該当するDateオブジェクトを生成する。
> こちらも暦の切替点をオプションで指定可能である。
>
> Date.jd
> 与えられたユリウス通日（Julian Day Number）に対応するDateオブジェクトを返す。
> 暦の切替点をオプションで指定できる。
>
> Date.today
> システムの日付（現在の日付）に対応するDateオブジェクトを返す。
> ローカルのタイムゾーン設定に依存する。
>
> Date.parse
> 与えられた文字列を解析し、内部でDate._parseを用いて日付要素を抽出後、Dateオブジェクトを生成する。
> 第二引数comp（既定はfalse）により、不完全な日付文字列に対して補完を行うかどうかを指定できる。
>
> Date.strptime
> 指定されたフォーマット文字列に従って、与えられた文字列を解析し、Dateオブジェクトを生成する。
> comp引数により、補完の有無を制御できる。
>
> Date.iso8601
> ISO 8601規格に準拠した日付文字列を解析して、Dateオブジェクトを生成する。
> 内部ではDate.parseと類似の処理を行うが、ISO 8601形式に特化している。
>
> Date.rfc3339
> RFC 3339形式の日付文字列を解析し、Dateオブジェクトを生成する。
> ISO 8601とほぼ同等の扱いとなる場合が多い。
>
> Date._parse
> 与えられた文字列を解析し、:year、:mon、:mday、:secなどのキーを持つハッシュを返す内部用メソッドである。
> このハッシュを元に他のパブリックメソッド（parse、strptime等）がDateオブジェクトを構築する。
>
> Date.leap?
> 指定した年がうるう年であるかどうかを判定し、真偽値を返す。
> 西暦のうるう年判定規則（4で割り切れるが100で割り切れず、または400で割り切れる）に基づく。
>
> Date.valid_date?
> 与えられた年、月、日が実在する日付かどうかを判定し、真偽値を返す。
> 存在しない日（例：2月30日）などの場合はfalseとなる。
>
> 以上が、Ruby 3.4におけるDateクラスの主要な特異メソッドとその仕様である。
</details>

- メソッドの網羅性：○
  - 主要なメソッドを13個程度列挙
  - 内部メソッドは適切に省略

- 説明の正確性：◎
  - 各メソッドの機能を詳細に解説
  - オプション引数や戻り値の説明も充実

- 構造化：○
  - メソッドごとに段落を分けて説明
  - 関連するメソッドをグループ化して解説

## 分析結果の考察

1. ドキュメント範囲内の質問に対する効果
   - Projects機能を使用することで、より網羅的で正確な情報を提供
   - 特に、メソッドの完全な一覧と詳細な仕様の説明において優位性を示す
   - 応答時間も15秒と、Projects不使用時（41秒）と比べて大幅に短縮

2. ドキュメント範囲外の質問に対する影響
   - Projects機能の有無による大きな差は見られない
   - むしろProjects不使用時の方が、より体系的な説明を提供
   - 応答時間はProjects使用時の方が短い（10秒 vs 34秒）

3. 全体的な傾向
   - ドキュメント範囲内の質問では、RAGの効果が顕著
   - 範囲外の質問では、既存の知識ベースで十分な回答が可能
   - 応答時間は全般的にProjects使用時の方が短い

## まとめ

RAG（Projects機能）の使用は、特定のドメイン（今回の場合はRubyの組み込みライブラリ）に関する質問において、より正確で網羅的な回答を提供することが確認できました。一方で、範囲外の質問に対しては、必ずしも優位性を示さないことも分かりました。

この結果から、RAGは以下のような用途に特に効果的だと考えられます：

- 特定の技術文書やAPI仕様の正確な参照が必要な場合
- 網羅的な情報収集が求められる場合
- 応答時間の短縮が重要な場合

ただし、RAGを効果的に活用するためには、適切な範囲のドキュメントを準備することが重要です。また、今回の実験ではinstructionsを使用できなかったため、より詳細な制御が可能な場合には、さらなる改善が期待できるかもしれません。
